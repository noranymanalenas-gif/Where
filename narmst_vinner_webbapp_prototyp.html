<!DOCTYPE html>
<html lang="sv">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Närmast Vinner — Multiplayer Prototyp</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    body { font-family: Inter, Arial, sans-serif; margin: 0; display:flex; height:100vh; }
    #left { width: 360px; min-width:280px; max-width:420px; padding:12px; box-sizing:border-box; border-right:1px solid #eee; overflow:auto }
    #map { flex:1; height:100%; }
    input, select, button { width:100%; padding:8px; margin:6px 0; box-sizing:border-box }
    .small { width:48%; display:inline-block }
    .row { display:flex; gap:8px }
    .players, .guesses { margin-top:10px }
    .player { padding:6px; border-bottom:1px solid #f1f1f1 }
    .admin-badge { background:#333;color:#fff;padding:2px 6px;border-radius:4px;font-size:12px }
  </style>
</head>
<body>
  <div id="left">
    <h2>Närmast Vinner — Multiplayer</h2>

    <label>Spelarnamn</label>
    <input id="playerName" placeholder="Ditt namn (ex: Anna)" />

    <label>Rumskod (skapa eller gå med)</label>
    <input id="roomId" placeholder="Ex: fika123" />
    <div class="row">
      <button id="createBtn">Skapa rum</button>
      <button id="joinBtn">Gå med</button>
    </div>

    <div id="adminPanel" class="hidden">
      <h3>Adminkontroller</h3>
      <label>Förvald tid (sek)</label>
      <input id="roundDuration" type="number" value="30" />

      <label>Välj mål (dubbelklicka på kartan för att lägga till eller använd lat,lng)</label>
      <input id="latlng" placeholder="lat,lng" />
      <div class="row">
        <button id="addPointBtn">Lägg till mål</button>
        <button id="clearTargetsBtn">Rensa mål</button>
      </div>

      <button id="startRoundBtn">Starta runda</button>
      <button id="revealBtn">Avslöja målet nu</button>
    </div>

    <div id="playerControls" class="hidden">
      <p id="status">Inte ansluten</p>
      <p id="timer">Tid: —</p>
      <button id="makeGuessBtn" disabled>Gissa (klicka på kartan)</button>
    </div>

    <h4>Spelare</h4>
    <div id="players" class="players"></div>

    <h4>Resultat / avstånd</h4>
    <div id="results" class="guesses"></div>

    <p style="margin-top:12px;font-size:13px;color:#666">Anm: Byt ut firebaseConfig i koden med ditt Firebase-projekt och aktivera Realtime Database (read/write under test eller säkra regler). Använd anonym inloggning i Authentication.</p>
  </div>

  <div id="map"></div>

  <script type="module">
    // ======= IMPORTANT =======
    // Replace the firebaseConfig below with your Firebase project's config.
    // Enable Authentication -> Sign-in method -> Anonymous
    // Enable Realtime Database and set rules suitable for testing.
    // ==========================

    import { initializeApp } from 'https://www.gstatic.com/firebasejs/9.24.0/firebase-app.js';
    import { getDatabase, ref, push, set, onValue, update, get, child, remove } from 'https://www.gstatic.com/firebasejs/9.24.0/firebase-database.js';
    import { getAuth, signInAnonymously } from 'https://www.gstatic.com/firebasejs/9.24.0/firebase-auth.js';

    const firebaseConfig = {
      apiKey: "REPLACE_ME",
      authDomain: "REPLACE_ME",
      databaseURL: "REPLACE_ME",
      projectId: "REPLACE_ME",
      storageBucket: "REPLACE_ME",
      messagingSenderId: "REPLACE_ME",
      appId: "REPLACE_ME"
    };

    const app = initializeApp(firebaseConfig);
    const db = getDatabase(app);
    const auth = getAuth(app);

    // Anonymous sign-in
    let currentUid = null;
    signInAnonymously(auth).then(cred => {
      currentUid = cred.user.uid;
      console.log('Signed in anonymously', currentUid);
    }).catch(err => console.error(err));

    // Leaflet map
    const Lcss = 'https://unpkg.com/leaflet@1.9.4/dist/leaflet.css';
    const mapDiv = document.getElementById('map');
    const map = L.map(mapDiv).setView([59.3293,18.0686],5);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);

    // UI refs
    const playerNameInput = document.getElementById('playerName');
    const roomIdInput = document.getElementById('roomId');

    const createBtn = document.getElementById('createBtn');
    const joinBtn = document.getElementById('joinBtn');

    const adminPanel = document.getElementById('adminPanel');
    const playerControls = document.getElementById('playerControls');
    const playersDiv = document.getElementById('players');
    const resultsDiv = document.getElementById('results');

    const startRoundBtn = document.getElementById('startRoundBtn');
    const revealBtn = document.getElementById('revealBtn');
    const roundDurationInput = document.getElementById('roundDuration');
    const statusP = document.getElementById('status');
    const timerP = document.getElementById('timer');
    const makeGuessBtn = document.getElementById('makeGuessBtn');
    const latlngInput = document.getElementById('latlng');
    const addPointBtn = document.getElementById('addPointBtn');
    const clearTargetsBtn = document.getElementById('clearTargetsBtn');

    let roomRef = null;
    let localRoomId = null;
    let isAdmin = false;
    let localPlayer = null;

    // Map markers
    let myGuessMarker = null;
    let targetMarkers = {};

    // Create room
    createBtn.addEventListener('click', async () => {
      const roomId = roomIdInput.value.trim();
      const name = playerNameInput.value.trim();
      if (!roomId || !name) return alert('Ange rumskod och namn');

      localRoomId = roomId;
      roomRef = ref(db, `rooms/${roomId}`);
      isAdmin = true;

      // Initialize room state
      await set(roomRef, {
        created: Date.now(),
        adminUid: currentUid,
        players: {},
        targets: {},
        round: { status: 'idle' }
      });

      joinRoomAsPlayer(name);
      adminPanel.classList.remove('hidden');
      playerControls.classList.remove('hidden');
      statusP.innerText = 'Du är admin — vänta på att starta runda';
      setupRealtimeListeners();
    });

    // Join room
    joinBtn.addEventListener('click', async () => {
      const roomId = roomIdInput.value.trim();
      const name = playerNameInput.value.trim();
      if (!roomId || !name) return alert('Ange rumskod och namn');

      localRoomId = roomId;
      roomRef = ref(db, `rooms/${roomId}`);

      // Ensure room exists (create minimal if not)
      const snapshot = await get(roomRef);
      if (!snapshot.exists()) {
        // create basic structure (no admin)
        await set(roomRef, { created: Date.now(), adminUid: null, players: {}, targets: {}, round: { status: 'idle' } });
      }

      joinRoomAsPlayer(name);
      adminPanel.classList.add('hidden');
      playerControls.classList.remove('hidden');
      statusP.innerText = 'Ansluten — vänta på att runda startar';
      setupRealtimeListeners();
    });

    async function joinRoomAsPlayer(name) {
      localPlayer = { uid: currentUid, name };
      const playerRef = ref(db, `rooms/${localRoomId}/players/${currentUid}`);
      await set(playerRef, { name, joined: Date.now(), guess: null });
    }

    // Add target (admin)
    addPointBtn.addEventListener('click', async () => {
      if (!isAdmin) return;
      const v = latlngInput.value.trim();
      if (!v) return alert('Ange lat,lng eller dubbelklicka på kartan');
      const parts = v.split(',').map(s => parseFloat(s.trim()));
      if (parts.length !== 2 || isNaN(parts[0]) || isNaN(parts[1])) return alert('Fel format');
      const tRef = push(ref(db, `rooms/${localRoomId}/targets`));
      await set(tRef, { lat: parts[0], lng: parts[1], created: Date.now() });
      latlngInput.value = '';
    });

    clearTargetsBtn.addEventListener('click', async () => {
      if (!isAdmin) return;
      await set(ref(db, `rooms/${localRoomId}/targets`), {});
    });

    // Map double-click adds target (admin)
    map.on('dblclick', async (e) => {
      if (!isAdmin || !localRoomId) return;
      const tRef = push(ref(db, `rooms/${localRoomId}/targets`));
      await set(tRef, { lat: e.latlng.lat, lng: e.latlng.lng, created: Date.now() });
    });

    // Start round (admin)
    startRoundBtn.addEventListener('click', async () => {
      if (!isAdmin) return;
      const dur = parseInt(roundDurationInput.value,10) || 30;
      // Set round object with start timestamp
      await update(ref(db, `rooms/${localRoomId}/round`), { status: 'running', start: Date.now(), duration: dur, revealed: false });
    });

    // Reveal immediately
    revealBtn.addEventListener('click', async () => {
      if (!isAdmin) return;
      await update(ref(db, `rooms/${localRoomId}/round`), { revealed: true });
    });

    // Player can make a guess (click on map) but only once per round
    let hasGuessedThisRound = false;

    map.on('click', async (e) => {
      if (!localRoomId || !localPlayer) return;
      // Check round status
      const roundSnap = await get(ref(db, `rooms/${localRoomId}/round`));
      if (!roundSnap.exists() || roundSnap.val().status !== 'running') return;

      // Check if already guessed
      const playerSnap = await get(ref(db, `rooms/${localRoomId}/players/${currentUid}/guess`));
      if (playerSnap.exists()) return alert('Du har redan gissat den här rundan.');

      // Save guess
      const guess = { lat: e.latlng.lat, lng: e.latlng.lng, time: Date.now() };
      await set(ref(db, `rooms/${localRoomId}/players/${currentUid}/guess`), guess);
    });

    // Listen to realtime updates for players, targets, and round
    function setupRealtimeListeners() {
      // players
      onValue(ref(db, `rooms/${localRoomId}/players`), (snap) => {
        const val = snap.val() || {};
        playersDiv.innerHTML = '';
        Object.keys(val).forEach(uid => {
          const p = val[uid];
          const el = document.createElement('div');
          el.className = 'player';
          el.innerHTML = `<strong>${p.name}</strong> ${uid===currentUid?'<span class="admin-badge">DU</span>':''}` +
                         `<div style="font-size:12px;color:#666">Gissning: ${p.guess? 'satt' : '—'}</div>`;
          playersDiv.appendChild(el);
        });
      });

      // targets
      onValue(ref(db, `rooms/${localRoomId}/targets`), (snap) => {
        const val = snap.val() || {};
        // clear markers
        Object.values(targetMarkers).forEach(m => map.removeLayer(m));
        targetMarkers = {};
        Object.keys(val).forEach(k => {
          const t = val[k];
          const m = L.circleMarker([t.lat, t.lng], { radius:8 }).addTo(map).bindPopup('Mål');
          targetMarkers[k] = m;
        });
      });

      // round
      onValue(ref(db, `rooms/${localRoomId}/round`), (snap) => {
        const round = snap.val() || { status: 'idle' };
        if (round.status === 'running') {
          isRoundRunning(round);
        } else {
          timerP.innerText = 'Ingen aktiv runda';
        }

        if (round.revealed) {
          // compute results
          computeResultsAndShow();
        }
      });

      // results listener (players' guesses)
      onValue(ref(db, `rooms/${localRoomId}/players`), (snap) => {
        const val = snap.val() || {};
        // show simple list with guess status; precise results computed when revealed
        resultsDiv.innerHTML = '';
        Object.keys(val).forEach(uid => {
          const p = val[uid];
          const div = document.createElement('div');
          div.className = 'player';
          let txt = `<strong>${p.name}</strong>`;
          if (p.guess) txt += `<div style="font-size:13px;color:#444">Gissat</div>`;
          resultsDiv.appendChild(div).innerHTML = txt;
        });
      });
    }

    // Handle running round: show timer
    let timerInterval = null;
    function isRoundRunning(round) {
      const start = round.start;
      const dur = round.duration || 30;
      const now = Date.now();
      const end = start + dur*1000;
      const left = Math.max(0, Math.round((end-now)/1000));
      timerP.innerText = `Tid kvar: ${left}s`;
      if (timerInterval) clearInterval(timerInterval);
      timerInterval = setInterval(() => {
        const n = Date.now();
        const l = Math.max(0, Math.round((end-n)/1000));
        timerP.innerText = `Tid kvar: ${l}s`;
        if (l <= 0) {
          clearInterval(timerInterval);
          // mark round as ended server-side by setting status idle but keep revealed false
          update(ref(db, `rooms/${localRoomId}/round`), { status: 'ended' });
          // Optionally auto-reveal after end: compute and set revealed true
          // We'll auto-reveal after 2s
          setTimeout(() => update(ref(db, `rooms/${localRoomId}/round`), { revealed: true }), 2000);
        }
      }, 500);
    }

    // Compute distances between target(s) and guesses and show winner
    async function computeResultsAndShow() {
      const roomSnap = await get(ref(db, `rooms/${localRoomId}`));
      const room = roomSnap.val();
      if (!room) return;

      // choose a single target to compare to: if multiple targets, pick the most recent
      const targets = room.targets || {};
      const targetKeys = Object.keys(targets);
      if (targetKeys.length === 0) return alert('Inga mål att jämföra mot');
      const lastKey = targetKeys[targetKeys.length -1];
      const target = targets[lastKey];

      // compute distances
      const players = room.players || {};
      const results = [];
      Object.keys(players).forEach(uid => {
        const p = players[uid];
        if (p.guess) {
          const d = haversine(target.lat, target.lng, p.guess.lat, p.guess.lng);
          results.push({ name: p.name, uid, distance_km: d, guess: p.guess });
        }
      });

      results.sort((a,b) => a.distance_km - b.distance_km);

      // render
      resultsDiv.innerHTML = '';
      results.forEach((r, idx) => {
        const el = document.createElement('div');
        el.className = 'player';
        el.innerHTML = `<strong>#${idx+1} ${r.name}</strong> — ${r.distance_km.toFixed(2)} km`;
        resultsDiv.appendChild(el);
      });

      if (results.length > 0) {
        const winner = results[0];
        alert(`Vinnare: ${winner.name} — ${winner.distance_km.toFixed(2)} km`);
      }

      // show target marker prominently
      Object.values(targetMarkers).forEach(m => map.removeLayer(m));
      const m = L.marker([target.lat, target.lng]).addTo(map).bindPopup('Rätt mål').openPopup();
      targetMarkers = { revealed: m };
    }

    function haversine(lat1, lon1, lat2, lon2) {
      const R = 6371; // km
      const dLat = toRad(lat2-lat1);
      const dLon = toRad(lon2-lon1);
      const a = Math.sin(dLat/2)*Math.sin(dLat/2) + Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLon/2)*Math.sin(dLon/2);
      return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    }
    function toRad(v){return v*Math.PI/180}

    // Clean up guesses between rounds (admin action)
    // Admin could reset players' guesses by removing guess keys
    // Not wired to UI for brevity; can be added later.

    // On page unload, remove player
    window.addEventListener('beforeunload', async () => {
      if (localRoomId && currentUid) {
        try { await remove(ref(db, `rooms/${localRoomId}/players/${currentUid}`)); } catch(e){}
      }
    });

    // Optional: makeGuessBtn UI (not strictly necessary with map click)
    makeGuessBtn.addEventListener('click', () => alert('Klicka på kartan för att gissa — endast en gång per runda'));

    // End of module
  </script>

  <!-- Leaflet JS (outside module for compatibility) -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
</body>
</html>
<!DOCTYPE html>
<html lang="sv">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Närmast Vinner - Geografispel</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
        integrity="sha256-p4NxAoJBhIINfQPDWHyDn7QgCjPuD4fAFrAgWfbTjSfd8c8zhBE4BcpMkpPI7rY6"
        crossorigin=""/>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="container">
        <h1>Var är jag?</h1>
        <p>Gissa var på kartan bilden är tagen!</p>

        <div id="image-container">
            <img id="location-image" src="" alt="Destination Image">
            <p id="loading-text">Laddar ny destination...</p>
        </div>

        <button id="startGameButton" class="btn">Starta nytt spel</button>
        <button id="guessButton" class="btn" style="display: none;">Gissa platsen</button>
        <button id="nextRoundButton" class="btn" style="display: none;">Nästa omgång</button>

        <div id="map-container">
            <div id="map"></div> <p id="instruction" style="display: none;">Klicka på kartan för att placera din gissning.</p>
        </div>
        
        <div id="result" style="display: none;">
            <p>Du gissade: <span id="distance"></span> km bort!</p>
            <p>Rätt plats:</p>
            <p id="correct-coords"></p>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
        integrity="sha256-20nQCchB9co0qIjJNQFmrZ+FJ6BuE0PaQ+CgMfD/scXhAVRU/HDVaAD2FvvhpNAw"
        crossorigin=""></script>
    <script src="script.js"></script>
</body>
</html>
body {
    font-family: Arial, sans-serif;
    display: flex;
    justify-content: center;
    align-items: flex-start; /* Justera till toppen */
    min-height: 100vh;
    margin: 0;
    background-color: #f4f4f4;
    padding: 20px; /* Lägg till lite padding runt om */
    box-sizing: border-box; /* Se till att padding inte förstör bredden */
}

.container {
    background-color: #fff;
    padding: 30px;
    border-radius: 8px;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    text-align: center;
    max-width: 800px; /* Begränsa bredden för bättre läsbarhet */
    width: 100%;
}

h1 {
    color: #333;
    margin-bottom: 10px;
}

p {
    color: #555;
    margin-bottom: 20px;
}

#image-container {
    margin-bottom: 20px;
    background-color: #eee;
    padding: 10px;
    border-radius: 5px;
    min-height: 200px; /* Minsta höjd för att undvika layouthopp */
    display: flex;
    justify-content: center;
    align-items: center;
    flex-direction: column;
}

#location-image {
    max-width: 100%;
    height: auto;
    max-height: 400px; /* Begränsa höjden på bilden */
    border-radius: 5px;
    display: block; /* Tar bort extra utrymme under bilden */
    margin: 0 auto; /* Centrera bilden */
}

#loading-text {
    font-style: italic;
    color: #777;
}

.btn {
    background-color: #007bff;
    color: white;
    padding: 10px 20px;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-size: 16px;
    margin: 5px;
    transition: background-color 0.2s ease;
}

.btn:hover {
    background-color: #0056b3;
}

#map-container {
    margin-top: 20px;
    border: 1px solid #ccc;
    border-radius: 5px;
    overflow: hidden; /* För att hålla kartan inom ramen */
}

#map {
    height: 400px; /* Höjd på kartan */
    width: 100%;
    display: none; /* Dölj kartan initialt */
}

#instruction {
    font-style: italic;
    color: #777;
    margin-top: 10px;
}

#result {
    margin-top: 20px;
    padding: 15px;
    background-color: #e9f7ef; /* Ljusgrön bakgrund för resultat */
    border: 1px solid #d4edda;
    border-radius: 5px;
    color: #155724; /* Mörkgrön text */
}

#result p {
    margin-bottom: 5px;
}

// Globala variabler
let map;
let marker; // För att visa spelarens gissning
let correctMarker; // För att visa den rätta platsen
let currentDestination;

// Array med destinationer (lägger in några exempel, du kan lägga till hur många du vill!)
// Varje objekt har:
//   - name: Namnet på platsen
//   - lat: Latitud (breddgrad)
//   - lng: Longitud (längdgrad)
//   - imageUrl: Sökvägen till bilden. Lägg bilderna i en 'images'-mapp.
const destinations = [
    { name: "Eiffeltornet, Paris", lat: 48.8584, lng: 2.2945, imageUrl: "images/eiffel.jpg" },
    { name: "Grand Canyon, USA", lat: 36.1000, lng: -112.1000, imageUrl: "images/grand_canyon.jpg" },
    { name: "Frihetsgudinnan, New York", lat: 40.6892, lng: -74.0445, imageUrl: "images/statue_of_liberty.jpg" },
    { name: "Taj Mahal, Indien", lat: 27.1750, lng: 78.0422, imageUrl: "images/taj_mahal.jpg" },
    { name: "Colosseum, Rom", lat: 41.8902, lng: 12.4922, imageUrl: "images/colosseum.jpg" }
    // Lägg till fler destinationer här!
];

// Funktion för att beräkna avstånd mellan två punkter (Haversine-formeln)
function calculateDistance(lat1, lon1, lat2, lon2) {
    const R = 6371; // Jordens radie i kilometer
    const dLat = (lat2 - lat1) * Math.PI / 180;
    const dLon = (lon2 - lon1) * Math.PI / 180;
    const a = 
        Math.sin(dLat / 2) * Math.sin(dLat / 2) +
        Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * Math.sin(dLon / 2) * Math.sin(dLon / 2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    const distance = R * c; // Avstånd i kilometer
    return distance;
}

// Funktion för att starta en ny omgång
function startNewRound() {
    // Slumpa fram en ny destination
    const randomIndex = Math.floor(Math.random() * destinations.length);
    currentDestination = destinations[randomIndex];

    // Visa laddningstext och dölj kartan/resultat
    document.getElementById('loading-text').style.display = 'block';
    document.getElementById('location-image').style.display = 'none';
    document.getElementById('map').style.display = 'none';
    document.getElementById('instruction').style.display = 'none';
    document.getElementById('result').style.display = 'none';
    document.getElementById('guessButton').style.display = 'none';
    document.getElementById('nextRoundButton').style.display = 'none';
    document.getElementById('startGameButton').style.display = 'block'; // Visa startknappen igen

    // Ta bort gamla markörer om de finns
    if (marker) {
        map.removeLayer(marker);
        marker = null;
    }
    if (correctMarker) {
        map.removeLayer(correctMarker);
        correctMarker = null;
    }

    // Ladda bilden
    const imgElement = document.getElementById('location-image');
    imgElement.src = currentDestination.imageUrl;
    imgElement.onload = () => {
        document.getElementById('loading-text').style.display = 'none';
        imgElement.style.display = 'block';
        document.getElementById('startGameButton').style.display = 'block'; // Se till att startknappen syns efter bildladdning
    };
    imgElement.onerror = () => {
        document.getElementById('loading-text').textContent = "Kunde inte ladda bild.";
        console.error("Kunde inte ladda bild för: " + currentDestination.name);
    };

    // Återställ kartvyn
    if (map) {
        map.setView([0, 0], 2); // Zooma ut till hela världen
    }
}

// Funktion för att initialisera kartan
function initMap() {
    // Initialisera kartan med Leaflet
    map = L.map('map').setView([0, 0], 2); // Centrera på [0,0] med zoomnivå 2 (hela världen)

    // Lägg till OpenStreetMap-brickor
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
    }).addTo(map);

    // Hantera klick på kartan
    map.on('click', function(e) {
        if (!marker) { // Lägg bara till en markör om ingen redan finns
            marker = L.marker(e.latlng).addTo(map)
                .bindPopup("Din gissning").openPopup();
            document.getElementById('guessButton').style.display = 'block'; // Visa gissningsknappen
        } else { // Flytta markören om den redan finns
            marker.setLatLng(e.latlng);
            marker.getPopup().setContent("Din gissning").openPopup();
        }
    });
}

// Händelselyssnare när sidan laddas
document.addEventListener('DOMContentLoaded', () => {
    initMap(); // Initialisera kartan direkt
    startNewRound(); // Starta första omgången

    // Hantera "Starta nytt spel" knappen
    document.getElementById('startGameButton').addEventListener('click', () => {
        document.getElementById('startGameButton').style.display = 'none'; // Dölj startknappen
        document.getElementById('location-image').style.display = 'block'; // Visa bilden igen
        document.getElementById('map').style.display = 'block'; // Visa kartan
        document.getElementById('instruction').style.display = 'block'; // Visa instruktionen
        map.invalidateSize(); // Se till att kartan renderas korrekt efter att ha blivit synlig
    });

    // Hantera "Gissa platsen" knappen
    document.getElementById('guessButton').addEventListener('click', () => {
        if (!marker) {
            alert('Vänligen klicka på kartan för att placera din gissning!');
            return;
        }

        document.getElementById('guessButton').style.display = 'none'; // Dölj gissningsknappen
        document.getElementById('nextRoundButton').style.display = 'block'; // Visa "Nästa omgång" knappen

        const guessedLat = marker.getLatLng().lat;
        const guessedLng = marker.getLatLng().lng;

        const correctLat = currentDestination.lat;
        const correctLng = currentDestination.lng;

        // Visa den korrekta platsen på kartan
        correctMarker = L.marker([correctLat, correctLng], {
            icon: L.icon({
                iconUrl: 'https://cdn.rawgit.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-green.png',
                shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
                iconSize: [25, 41],
                iconAnchor: [12, 41],
                popupAnchor: [1, -34],
                shadowSize: [41, 41]
            })
        }).addTo(map)
        .bindPopup(`Rätt plats: ${currentDestination.name}`).openPopup();

        // Rita en linje mellan gissningen och den rätta platsen
        L.polyline([[guessedLat, guessedLng], [correctLat, correctLng]], {color: 'red'}).addTo(map);

        // Beräkna och visa avståndet
        const distance = calculateDistance(guessedLat, guessedLng, correctLat, correctLng);
        document.getElementById('distance').textContent = distance.toFixed(2); // Visa med 2 decimaler
        document.getElementById('correct-coords').textContent = `${correctLat.toFixed(4)}, ${correctLng.toFixed(4)} (${currentDestination.name})`;
        document.getElementById('result').style.display = 'block'; // Visa resultatdiven

        // Centrera kartan runt båda markörerna
        const bounds = L.latLngBounds(marker.getLatLng(), correctMarker.getLatLng());
        map.fitBounds(bounds, {padding: [50, 50]});
    });

    // Hantera "Nästa omgång" knappen
    document.getElementById('nextRoundButton').addEventListener('click', () => {
        startNewRound();
    });
});
